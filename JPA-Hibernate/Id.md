# @Id - Define primary key

As in tables, entities also require an identifier (@Id), this identifier must differentiate the entity from the rest. As a general rule, all entities must define an ID, otherwise we will cause the EntityManager to mark an error when instantiating it.

The ID is important because it will be used by EntityManager when persisting an object, and it is because of this that it can determine on which record to select, update or delete. JPA supports simple IDs of a single field or complex IDs, consisting of more than one field

```java
import javax.persistence.*;

@Entity
@Table(
    name = "EMPLOYEES" , 
    schema = "employeeschema", 
    indexes = {@Index(name = "name_index", columnList = "name",unique = true)}
)
public class Employee {
    @Id
    private Long id;
    private String name; 
}
```

The ID can be any data type supported by JPA, such as all primitive types and wraper classes, enumerations and Calendar. In general you can use the one that best suits your needs, but in particular I recommend that you never use the primitive types to define the primary keys, instead use the wraper classes, for example, instead of using int use Integer, instead of using double use Double, instead of long use Long, and so on for each data type. And the reason is very simple, primitive types do not accept Null values ​​which makes it not make sense with the beginning of the database, for example, if I defined the id of the employee as long, it would have an initial value of 0, although it doesn't actually have an ID, and if it were of type Long (wraper) it would start with a Null value. This when we work is much more manual than validating if an entity has id = 0 or <> 0 to know that the entity already exists in the database. This is just my advice and you can use primitive types if you want.

## @GeneratedValue annotation
At this point you are probably wondering how it knows if the ID is autogenerated (Identity) as in the case of MySQL and MS SQL Server, or if it is calculated through a sequence as in the case of Oracle and Postgres. Well, JPA has the @GeneratedValue annotation to indicate to JPA which autogeneration rule of the primary drive we are going to use.

JPA supports 4 primary key auto-generation strategies, which are described below:
- Identity
- Sequence
- Table 
- Auto

### Identity
This strategy is the easiest to use because you just have to indicate the strategy and voila, it does not require anything else, when the entity persists, JPA will not send this value, as it will assume that the column is auto generated. This causes the column counter to increment by 1 each time a new object is inserted.

```java
import javax.persistence.*;

@Entity
@Table(
    name = "EMPLOYEES" , 
    schema = "employeeschema", 
    indexes = {@Index(name = "name_index", columnList = "name",unique = true)}
)
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name; 
}
```

### Sequence
Using this strategy we tell JPA which ID to generate through a database sequence. In this way, when an insert is made, it will add the instruction so that the next value of the sequence is inserted in the ID

**Annotation @SequenceGenerator**
This annotation is generally defined at the class level, and is used to tell JPA what sequence to use to insert into the database.

```java
import javax.persistence.*;

@Entity
@Table(
    name = "EMPLOYEES" , 
    schema = "employeeschema", 
    indexes = {@Index(name = "name_index", columnList = "name",unique = true)}
)
@SequenceGenerator(
    name="EmployeeSeq",
    sequenceName = "EMPLOYEES_SEQ",
    initialValue = 1, 
    allocationSize = 10
)
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "EmployeeSeq")
    private Long id;
    private String name; 
}
```

The **@SequenceGenerator** annotation has the following properties:

- **name**: name with which the sequence is identified in JPA, this name does not correspond to the real name of the sequence in the database and must match the generator property of the @GeneratorValue annotation
- **sequenceName**: real name of the sequence in the database
- **initialValue**: initial value of the sequence, just in case JPA creates it
allocationSize: sequence increment, only in case JPA creates it

### Table

This is a special JPA strategy, which does not depend on the database used as is the case of Sequence and Identity, since this strategy creates a table only to control a sequence auto-generated by Entity. It can be confusing, but in reality what this strategy does is simulate the Identity strategy by creating a table with two columns, the first the name of the entity and the second the last ID used, in this way, when a new object is inserted, query the last ID of that entity, increments it and assigns it to the new entity at the same time that it updates the table with the last ID used.

This strategy is used more than anything for its portability, but it is always better to use native database strategies such as sequences and identity as they tend to have better performance.

**@TableGenerator annotation**
Like the sequence strategy, it is necessary to tell JPA which table to use to store the sequences by Entity.

```java
import javax.persistence.*;

@Entity
@Table(
    name = "EMPLOYEES" , 
    schema = "employeeschema", 
    indexes = {@Index(name = "name_index", columnList = "name",unique = true)}
)
@TableGenerator(
    name = "EmployeeTable", 
    initialValue = 1, 
    pkColumnName = "ENTITY", 
    pkColumnValue = "ID", 
    allocationSize = 10, 
    table = "ENTITY_GENERATOR"
)
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "EmployeeTable")
    private Long id;
    private String name;
}
```

The **@TableGenerator** annotation has the following properties:

- **name**: name with which the table is identified in JPA, this name does not correspond to the real name of the table in the database and must match the generator property of the @GeneratorValue annotation
- **table**: real name of the table in the database
- **pkColumnName**: real name of the column in which the name of the sequence will be saved
- **pkColumnValue**: real name of the column in which the last generated ID will be saved
- **initialValue**: value with which the sequence will start
- **allocationSize**: sequence increment

### Auto
Finally, all this strategy does is tell JPA to use the default strategy for the database we are working with. In particular, it is the one that I recommend the least because we leave the 
strategy to JPA interpretation and this can leave us a lot of headaches.

```Important```: In the case of not declaring the @GeneratedValue annotation, JPA will assume that there is no autogeneration strategy, so it will be necessary to set the ID manually before persisting the entity.
